---
description: Standardized codebase patterns (Resonance Filters: Constructive and Destructive Interference Patterns)
alwaysApply: false
---
# Resonance Filters: Constructive and Destructive Interference Patterns

## Constructive Interference Patterns (Enforce These)

### Type Safety & Annotations

```python
# ✓ GOOD: Comprehensive type hints
from typing import Optional, Dict, List, Tuple
import torch

def calculate_purity(
    spectrum: torch.Tensor,
    threshold: float = 0.1
) -> float:
    """Calculate spectral purity from feature activations."""
    pass
```

```python
# ✗ BAD: Missing type hints
def calculate_purity(spectrum, threshold=0.1):
    pass
```

### Device Handling

```python
# ✓ GOOD: Automatic device detection with fallback
import torch

def get_device() -> torch.device:
    """Automatically select best available device."""
    if torch.backends.mps.is_available():
        return torch.device("mps")
    elif torch.cuda.is_available():
        return torch.device("cuda")
    else:
        return torch.device("cpu")
```

```python
# ✗ BAD: Hardcoded device or no device handling
device = torch.device("cuda")  # Will fail on Mac
```

### Memory Management

```python
# ✓ GOOD: Explicit cleanup and context managers
import torch
from contextlib import contextmanager

@contextmanager
def model_context(model, sae):
    """Context manager for model loading/unloading."""
    try:
        yield model, sae
    finally:
        del model, sae
        torch.cuda.empty_cache() if torch.cuda.is_available() else None
        torch.mps.empty_cache() if torch.backends.mps.is_available() else None
```

```python
# ✗ BAD: No cleanup, memory leaks
model = load_model()
sae = load_sae()
# ... use them ...
# Never cleaned up!
```

### Data Classes for Spectrum Objects

```python
# ✓ GOOD: Typed data class with validation
from dataclasses import dataclass
from typing import List, Optional
import torch

@dataclass
class Spectrum:
    """Represents a spectral decomposition of LLM activations."""
    wavelengths: torch.Tensor  # Feature indices
    intensities: torch.Tensor  # Activation magnitudes
    model_name: str
    layer: int
    
    def __post_init__(self):
        """Validate spectrum data."""
        assert len(self.wavelengths) == len(self.intensities), \
            "Wavelengths and intensities must have same length"
```

```python
# ✗ BAD: Dictionary or untyped structure
spectrum = {
    "w": [1, 2, 3],
    "i": [0.5, 0.3, 0.2]
}
```

### Docstrings

```python
# ✓ GOOD: Comprehensive docstrings with examples
def detect_absorption(
    input_spec: Spectrum,
    output_spec: Spectrum,
    threshold: float = 0.5
) -> List[int]:
    """
    Detect features present in input but absent in output.
    
    This implements the Absorption Blindness hypothesis (H3):
    If a model ignores an instruction, relevant concept features
    will be absent in output despite being present in input.
    
    Args:
        input_spec: Input spectrum with feature activations
        output_spec: Output spectrum to compare against
        threshold: Minimum intensity difference to consider absorption
        
    Returns:
        List of feature indices that were absorbed (present in input,
        absent in output)
        
    Example:
        >>> input_spec = Spectrum(wavelengths=[1,2,3], intensities=[0.8,0.6,0.4], ...)
        >>> output_spec = Spectrum(wavelengths=[1,3], intensities=[0.7,0.3], ...)
        >>> absorbed = detect_absorption(input_spec, output_spec)
        >>> print(absorbed)
        [2]
    """
    pass
```

```python
# ✗ BAD: No docstring or minimal docstring
def detect_absorption(input_spec, output_spec, threshold=0.5):
    # Detects absorption
    pass
```

### Modular Architecture

```python
# ✓ GOOD: Clear separation of concerns
class ExcitationController:
    """The Slit: Manages input formatting and feature steering."""
    pass

class SAE_Adapter:
    """The Prism: Loads SAEs and normalizes outputs."""
    pass

class InterferenceEngine:
    """The Detector: Mathematical analysis of spectra."""
    pass
```

```python
# ✗ BAD: Monolithic class doing everything
class UniversalSpectroscopyEngine:
    def __init__(self):
        # Everything in one class
        pass
    def format_input(self): pass
    def load_sae(self): pass
    def calculate_purity(self): pass
    def detect_drift(self): pass
    # ... all methods in one place
```

### Error Handling

```python
# ✓ GOOD: Specific exceptions with context
class SAELoadError(Exception):
    """Raised when SAE fails to load."""
    pass

def load_sae(model_name: str, layer: int) -> SAE:
    """Load SAE with proper error handling."""
    try:
        sae = load_sae_from_lens(model_name, layer)
    except FileNotFoundError as e:
        raise SAELoadError(
            f"SAE not found for {model_name} layer {layer}. "
            f"Available SAEs: {list_available_saes()}"
        ) from e
```

```python
# ✗ BAD: Generic exceptions or no error handling
def load_sae(model_name, layer):
    sae = load_sae_from_lens(model_name, layer)  # May crash
    return sae
```

## Destructive Interference Patterns (Block These)

### Anti-Pattern: Hardcoded Model Paths

```python
# ✗ BAD: Hardcoded paths
MODEL_PATH = "/Users/ariahan/models/llama-3-8b"
```

```python
# ✓ GOOD: Configurable or environment-based
import os
MODEL_PATH = os.getenv("USE_MODEL_PATH", "default/path")
```

### Anti-Pattern: No Version Checking

```python
# ✗ BAD: No compatibility checks
import transformer_lens
import sae_lens
# May break if versions incompatible
```

```python
# ✓ GOOD: Version validation
import transformer_lens
import sae_lens

def verify_compatibility():
    """Verify library versions are compatible."""
    tl_version = transformer_lens.__version__
    sae_version = sae_lens.__version__
    # Check compatibility matrix
```

### Anti-Pattern: Global State

```python
# ✗ BAD: Global variables
current_model = None
current_sae = None

def process(input_text):
    global current_model, current_sae
    # ...
```

```python
# ✓ GOOD: Instance state
class UniversalSpectroscopyEngine:
    def __init__(self):
        self.model = None
        self.sae = None
    
    def process(self, input_text):
        # Use self.model, self.sae
        pass
```

### Anti-Pattern: Ignoring Device Differences

```python
# ✗ BAD: Assuming CUDA
tensor = tensor.cuda()
```

```python
# ✓ GOOD: Device-agnostic
device = get_device()
tensor = tensor.to(device)
```

### Anti-Pattern: No Resource Cleanup

```python
# ✗ BAD: Loading models without cleanup
def analyze(text):
    model = load_huge_model()  # 10GB VRAM
    sae = load_huge_sae()       # 5GB VRAM
    result = process(model, sae, text)
    return result  # Models still in memory!
```

```python
# ✓ GOOD: Explicit cleanup
def analyze(text):
    with model_context(load_model(), load_sae()) as (model, sae):
        result = process(model, sae, text)
    return result  # Models cleaned up
```

## Project-Specific Patterns

### Spectrum Object Creation

```python
# ✓ GOOD: Standardized .spec format
@dataclass
class Spectrum:
    wavelengths: torch.Tensor  # Feature indices (sorted)
    intensities: torch.Tensor  # Activation magnitudes
    model_name: str
    layer: int
    metadata: Dict[str, Any]
    
    def to_spec_dict(self) -> Dict:
        """Convert to standardized .spec format."""
        return {
            "wavelengths": self.wavelengths.cpu().numpy().tolist(),
            "intensities": self.intensities.cpu().numpy().tolist(),
            "model": self.model_name,
            "layer": self.layer,
            "metadata": self.metadata
        }
```

### Hypothesis Implementation Pattern

```python
# ✓ GOOD: Clear hypothesis testing structure
class InterferenceEngine:
    """Implements the three core hypotheses."""
    
    def calculate_purity(self, spectrum: Spectrum) -> float:
        """
        H1: Spectral Purity Hypothesis
        Hallucinations manifest as low spectral purity.
        """
        # Implementation
        pass
    
    def calculate_drift(
        self, 
        spec_a: Spectrum, 
        spec_b: Spectrum
    ) -> float:
        """
        H2: Doppler Shift Hypothesis
        Semantic meaning shifts as information passes through chains.
        """
        # Implementation
        pass
    
    def detect_absorption(
        self,
        input_spec: Spectrum,
        output_spec: Spectrum
    ) -> List[int]:
        """
        H3: Absorption Blindness Hypothesis
        Missing features indicate ignored instructions.
        """
        # Implementation
        pass
```

## Code Organization Patterns

### Module Structure

``` bash
src/use/
├── __init__.py           # Package exports
├── engine.py            # UniversalSpectroscopyEngine main class
├── excitation.py        # ExcitationController (The Slit)
├── sae_adapter.py       # SAE_Adapter (The Prism)
├── interference.py      # InterferenceEngine (The Detector)
├── spectrum.py          # Spectrum data class
└── utils.py             # Device detection, helpers
```

### Import Organization

```python
# ✓ GOOD: Organized imports
# Standard library
from dataclasses import dataclass
from typing import Optional, Dict, List
import os

# Third-party
import torch
from transformer_lens import HookedTransformer
from sae_lens import SAE

# Local
from .spectrum import Spectrum
from .utils import get_device
```
